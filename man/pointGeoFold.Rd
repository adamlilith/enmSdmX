% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pointGeoFold.r
\name{pointGeoFold}
\alias{pointGeoFold}
\title{Assign geographically-distinct k-folds}
\usage{
pointGeoFold(
  x,
  k,
  kMin = 1,
  minIn = 1,
  collapseFolds = FALSE,
  longLat = 1:2,
  ...
)
}
\arguments{
\item{x}{A "spatial points" object of class \code{SpatVector}, \code{sf}, \code{data.frame}, or \code{matrix}. If \code{x} is a \code{data.frame} or \code{matrix}, then the points will be assumed to have the WGS84 coordinate system (i.e., unprojected).}

\item{k}{Number of folds to create.}

\item{kMin}{Minimum number of folds desired. This is used only if \code{collapseFolds} is \code{FALSE}. If >1, then the routine will collapse folds into one another to achieve the desired number of points per fold, but then switch to the swapping routine once there are \code{kMin} folds remaining.  The default is 1, meaning that the function would return a single fold if this was the only way to create a fold with sufficient number of points.}

\item{minIn}{Positive integer or \code{NULL}. Minimum number of sites required to be in a fold. If left \code{NULL} (default), it is possible to have just one site in a fold.}

\item{collapseFolds}{Either:
\itemize{
    \item If \code{TRUE} and there are fewer than \code{minIn} points in any fold, collapse folds with fewer than \code{minIn} points into neighboring folds to create larger (but fewer folds). This can sometimes create a single fold.  If this is undesirable, then try setting \code{kMin} to a number >1 but < \code{k}. This will turn the swapping routine on once there are \code{kMin} folds left.
    \item if \code{FALSE} (default) and there are fewer than \code{minIn} points in any fold, then force a swapping routine so that there will be at least \code{minIn} points in each fold. This can sometimes create folds that are "squished" between others.
}}

\item{longLat}{This is ignored if \code{x} is a \code{Spaytvector} or \code{sf} object. However, if \code{x} is a \code{data.frame} or \code{matrix}, then this should be a character or integer vector specifiying the columns in \code{x} corresponding to longitude and latitude (in that order). For example, \code{c('long', 'lat')} or \code{c(1, 2)}. The default is to assume that the first two columns in \code{x} represent coordinates.}

\item{...}{Additional arguments. Not used.}
}
\value{
A vector of integers the same length as the dimension of \code{x}. Each integer indicates which fold a point in \code{x} belongs to.
}
\description{
This function assigns geographically-divided k-folds ("g-folds") to a set of points based on clustering by proximity. Folds are created by grouping nearby points together. Users can force folds to have at least a minimum number of points by:
\itemize{
\item Swapping points between folds. This ensures the desired number of folds is produced, but can sometimes result in folds that are "squashed" between others.
	\item Collapsing smaller folds into nearby larger ones. This reduces the total number of folds, sometimes even down to a single fold.
	\item A hybrid approach in which folds can be collapsed until a threshold number of folds is reached, then the swapping rountine takes over. This helps ensure at least a given number of folds is produced, but is less likely to yield "squashed" folds.
}
Regardless of which method is used, the results are deterministic.
}
\examples{
library(sf)

# lemur occurrence data
data(mad0)
data(lemurs)
crs <- crsGet('WGS84')
occs <- lemurs[lemurs$species == 'Eulemur fulvus', ]
ll <- c('longitude', 'latitude')
occs <- st_as_sf(occs, coords = ll, crs = crsGet('WGS84'))

folds1 <- pointGeoFold(occs, k = 3)
folds2 <- pointGeoFold(occs, k = 3, minIn = 10)
folds3 <- pointGeoFold(occs, k = 3, minIn = 10, collapseFolds = TRUE)
folds4 <- pointGeoFold(occs, k = 3, minIn = 10, collapseFolds = TRUE, kMin = 2)

# map
par(mfrow=c(2, 2))
plot(st_geometry(occs), cex = 1.4, col = folds1, main = 'Swapping')
plot(st_geometry(mad0), add = TRUE)

plot(st_geometry(occs), cex = 1.4, col = folds2, main = 'Swapping, minIn = 10')
plot(st_geometry(mad0), add = TRUE)

plot(st_geometry(occs), cex = 1.4, col = folds3, main = 'Collapse, minIn = 10')
plot(st_geometry(mad0), add = TRUE)

plot(st_geometry(occs), cex = 1.4, col = folds4, main = 'Collapse --> swapping, minIn = 10')
plot(st_geometry(mad0), add = TRUE)

# number of points per fold
table(folds1) # default
table(folds2) # each fold has >= 10 (minIn)
table(folds3) # can yield just one fold when collapseFolds = TRUE
table(folds4) # collapsing then switch to swapping when k = 2
}
